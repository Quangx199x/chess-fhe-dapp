<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess vs AI - Web3 DApp</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .wallet-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .wallet-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .connect-btn, .difficulty-btn, .new-game-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .connect-btn:hover, .difficulty-btn:hover, .new-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .game-section {
            display: grid;
            grid-template-columns: 1fr auto 300px;
            gap: 30px;
            align-items: start;
        }

        .game-controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .difficulty-selector {
            margin-bottom: 20px;
        }

        .difficulty-selector h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .difficulty-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }

        .chess-board {
            width: 480px;
            height: 480px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            margin: 0 auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .square.light {
            background-color: #f0d9b5;
            color: #333;
        }

        .square.dark {
            background-color: #b58863;
            color: #333;
        }

        .square:hover {
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .square.selected {
            background-color: #7fa650 !important;
        }

        .square.possible-move {
            background-color: #7fa650 !important;
            opacity: 0.8;
        }

        .square.possible-move:after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
        }

        .game-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-panel {
            margin-bottom: 20px;
        }

        .status-panel h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .fhe-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .fhe-section h3 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid #4ecdc4;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
            max-width: 300px;
        }

        .notification.success {
            border-left: 4px solid #4ecdc4;
        }

        .notification.error {
            border-left: 4px solid #ff6b6b;
        }

        @media (max-width: 1024px) {
            .game-section {
                grid-template-columns: 1fr;
                justify-items: center;
            }

            .chess-board {
                width: 320px;
                height: 320px;
            }

            .square {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ôï Chess vs AI - Web3 DApp ‚ôõ</h1>
            <p>Ch∆°i c·ªù vua v·ªõi AI th√¥ng minh, t√≠ch h·ª£p blockchain v√† FHE</p>
        </div>

        <div class="wallet-section">
            <div class="wallet-info">
                <div>
                    <span id="wallet-status">Ch∆∞a k·∫øt n·ªëi v√≠</span>
                    <div id="wallet-address" style="font-size: 0.9em; opacity: 0.8; margin-top: 5px;"></div>
                </div>
                <button class="connect-btn" id="connect-wallet">K·∫øt n·ªëi MetaMask</button>
            </div>
        </div>

        <div class="game-section">
            <div class="game-controls">
                <div class="difficulty-selector">
                    <h3>ƒê·ªô kh√≥ AI</h3>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn active" data-level="1">D·ªÖ (Depth 1)</button>
                        <button class="difficulty-btn" data-level="2">Trung b√¨nh (Depth 2)</button>
                        <button class="difficulty-btn" data-level="3">Kh√≥ (Depth 3)</button>
                        <button class="difficulty-btn" data-level="4">Chuy√™n gia (Depth 4)</button>
                    </div>
                </div>
                <button class="new-game-btn" id="new-game">Game M·ªõi</button>
            </div>

            <div class="chess-board" id="chess-board">
                <!-- B√†n c·ªù s·∫Ω ƒë∆∞·ª£c t·∫°o b·∫±ng JavaScript -->
            </div>

            <div class="game-info">
                <div class="status-panel">
                    <h3>Tr·∫°ng th√°i game</h3>
                    <div id="game-status">L∆∞·ª£t c·ªßa b·∫°n (Tr·∫Øng)</div>
                    <div id="current-player" style="margin-top: 10px;"></div>
                </div>

                <div class="loading" id="ai-thinking">
                    <div class="spinner"></div>
                    <p>AI ƒëang suy nghƒ©...</p>
                </div>

                <h3>L·ªãch s·ª≠ n∆∞·ªõc ƒëi</h3>
                <div class="move-history" id="move-history">
                    Game m·ªõi - B·∫°n ƒëi tr∆∞·ªõc!
                </div>
            </div>
        </div>

        <div class="fhe-section">
            <h3>üîê FHE (Fully Homomorphic Encryption)</h3>
            <p>T√≠nh nƒÉng m√£ h√≥a ƒë·ªìng h√¨nh ƒë·∫ßy ƒë·ªß ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...</p>
            <div style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                <span id="fhe-status">Tr·∫°ng th√°i: Ch∆∞a k√≠ch ho·∫°t</span>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        // Chess Game Engine
        class ChessGame {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveHistory = [];
                this.aiDifficulty = 1;
                this.gameOver = false;
                this.initializeUI();
                this.bindEvents();
            }

            initializeBoard() {
                return [
                    ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                    ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                    ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
                ];
            }

            initializeUI() {
                const boardElement = document.getElementById('chess-board');
                boardElement.innerHTML = '';

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.textContent = this.board[row][col] || '';
                        
                        square.addEventListener('click', (e) => this.handleSquareClick(e));
                        boardElement.appendChild(square);
                    }
                }
                this.updateGameStatus();
            }

            handleSquareClick(event) {
                if (this.gameOver || this.currentPlayer === 'black') return;

                const row = parseInt(event.target.dataset.row);
                const col = parseInt(event.target.dataset.col);

                if (this.selectedSquare) {
                    if (this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        this.clearSelection();
                        return;
                    }

                    if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                        this.clearSelection();
                        
                        if (!this.gameOver) {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    } else {
                        this.clearSelection();
                        this.selectSquare(row, col);
                    }
                } else {
                    this.selectSquare(row, col);
                }
            }

            selectSquare(row, col) {
                if (!this.board[row][col] || !this.isPieceOwnedByCurrentPlayer(row, col)) {
                    return;
                }

                this.selectedSquare = { row, col };
                const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                square.classList.add('selected');
                this.highlightPossibleMoves(row, col);
            }

            clearSelection() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'possible-move');
                });
                this.selectedSquare = null;
            }

            highlightPossibleMoves(row, col) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.isValidMove(row, col, r, c)) {
                            const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            square.classList.add('possible-move');
                        }
                    }
                }
            }

            isPieceOwnedByCurrentPlayer(row, col) {
                const piece = this.board[row][col];
                if (!piece) return false;
                
                const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
                const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
                
                return (this.currentPlayer === 'white' && whitePieces.includes(piece)) ||
                       (this.currentPlayer === 'black' && blackPieces.includes(piece));
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
                if (fromRow === toRow && fromCol === toCol) return false;

                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];

                if (!piece) return false;
                if (targetPiece && this.isPieceOwnedByCurrentPlayer(toRow, toCol)) return false;

                // Simplified piece movement validation
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);

                switch (piece) {
                    case '‚ôô': // White pawn
                        if (fromCol === toCol) {
                            if (fromRow === 6 && toRow === 4 && !this.board[5][fromCol] && !targetPiece) return true;
                            if (toRow === fromRow - 1 && !targetPiece) return true;
                        } else if (colDiff === 1 && toRow === fromRow - 1 && targetPiece) {
                            return true;
                        }
                        return false;
                    
                    case '‚ôü': // Black pawn
                        if (fromCol === toCol) {
                            if (fromRow === 1 && toRow === 3 && !this.board[2][fromCol] && !targetPiece) return true;
                            if (toRow === fromRow + 1 && !targetPiece) return true;
                        } else if (colDiff === 1 && toRow === fromRow + 1 && targetPiece) {
                            return true;
                        }
                        return false;
                    
                    case '‚ôñ': case '‚ôú': // Rook
                        if (fromRow === toRow || fromCol === toCol) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case '‚ôó': case '‚ôù': // Bishop
                        if (rowDiff === colDiff) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case '‚ôï': case '‚ôõ': // Queen
                        if (fromRow === toRow || fromCol === toCol || rowDiff === colDiff) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case '‚ôò': case '‚ôû': // Knight
                        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                    
                    case '‚ôî': case '‚ôö': // King
                        return rowDiff <= 1 && colDiff <= 1;
                }
                
                return false;
            }

            isPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
                
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;
                
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (this.board[currentRow][currentCol]) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return true;
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                const moveNotation = `${piece} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} ‚Üí ${String.fromCharCode(97 + toCol)}${8 - toRow}${capturedPiece ? ` (x${capturedPiece})` : ''}`;
                this.moveHistory.push(moveNotation);
                
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.updateUI();
                this.checkGameEnd();
            }

            makeAIMove() {
                if (this.gameOver || this.currentPlayer === 'white') return;

                document.getElementById('ai-thinking').style.display = 'block';
                
                setTimeout(() => {
                    const bestMove = this.findBestMove();
                    if (bestMove) {
                        this.makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    }
                    document.getElementById('ai-thinking').style.display = 'none';
                }, 800);
            }

            findBestMove() {
                const possibleMoves = this.getAllPossibleMoves('black');
                if (possibleMoves.length === 0) return null;

                let bestMove = null;
                let bestScore = -Infinity;

                for (const move of possibleMoves) {
                    const score = this.evaluateMove(move);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }

                return bestMove;
            }

            getAllPossibleMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.board[row][col] && this.isPieceColor(row, col, color)) {
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (this.isValidMove(row, col, toRow, toCol)) {
                                        moves.push({ fromRow: row, fromCol: col, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
                return moves;
            }

            isPieceColor(row, col, color) {
                const piece = this.board[row][col];
                if (!piece) return false;
                
                const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
                const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
                
                return (color === 'white' && whitePieces.includes(piece)) ||
                       (color === 'black' && blackPieces.includes(piece));
            }

            evaluateMove(move) {
                const piece = this.board[move.fromRow][move.fromCol];
                const target = this.board[move.toRow][move.toCol];
                
                let score = Math.random() * 10; // Base randomness
                
                // Prioritize captures
                if (target) {
                    const pieceValues = { '‚ôõ': 9, '‚ôú': 5, '‚ôó': 3, '‚ôò': 3, '‚ôü': 1, '‚ôï': 9, '‚ôñ': 5, '‚ôó': 3, '‚ôò': 3, '‚ôô': 1 };
                    score += pieceValues[target] || 0;
                }
                
                // Center control bonus
                const centerDistance = Math.abs(3.5 - move.toRow) + Math.abs(3.5 - move.toCol);
                score += (7 - centerDistance) * 0.5;
                
                return score;
            }

            updateUI() {
                // Update board display
                document.querySelectorAll('.square').forEach(square => {
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    square.textContent = this.board[row][col] || '';
                });
                
                this.updateGameStatus();
                this.updateMoveHistory();
            }

            updateGameStatus() {
                const statusElement = document.getElementById('game-status');
                if (this.gameOver) {
                    statusElement.textContent = 'Game k·∫øt th√∫c';
                } else {
                    statusElement.textContent = this.currentPlayer === 'white' ? 
                        'L∆∞·ª£t c·ªßa b·∫°n (Tr·∫Øng)' : 'L∆∞·ª£t c·ªßa AI (ƒêen)';
                }
            }

            updateMoveHistory() {
                const historyElement = document.getElementById('move-history');
                historyElement.innerHTML = this.moveHistory.length > 0 ? 
                    this.moveHistory.map((move, index) => `${index + 1}. ${move}`).join('<br>') :
                    'Game m·ªõi - B·∫°n ƒëi tr∆∞·ªõc!';
                historyElement.scrollTop = historyElement.scrollHeight;
            }

            checkGameEnd() {
                // Simplified game end check
                const possibleMoves = this.getAllPossibleMoves(this.currentPlayer);
                if (possibleMoves.length === 0) {
                    this.gameOver = true;
                    this.updateGameStatus();
                }
            }

            newGame() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveHistory = [];
                this.gameOver = false;
                this.initializeUI();
            }

            setDifficulty(level) {
                this.aiDifficulty = level;
            }

            bindEvents() {
                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.setDifficulty(parseInt(e.target.dataset.level));
                        showNotification(`ƒê·ªô kh√≥ ƒë∆∞·ª£c ƒë·∫∑t: ${e.target.textContent}`, 'success');
                    });
                });

                // New game button
                document.getElementById('new-game').addEventListener('click', () => {
                    this.newGame();
                    showNotification('Game m·ªõi ƒë√£ b·∫Øt ƒë·∫ßu!', 'success');
                });
            }
        }

        // Web3 & MetaMask Integration
        class Web3Manager {
            constructor() {
                this.web3 = null;
                this.account = null;
                this.isConnected = false;
                this.bindEvents();
            }

            async connectWallet() {
                try {
                    if (typeof window.ethereum !== 'undefined') {
                        // Request account access
                        const accounts = await window.ethereum.request({
                            method: 'eth_requestAccounts'
                        });

                        if (accounts.length > 0) {
                            this.account = accounts[0];
                            this.isConnected = true;

                            // Switch to Sepolia network
                            await this.switchToSepolia();
                            
                            this.updateWalletUI();
                            showNotification('K·∫øt n·ªëi v√≠ th√†nh c√¥ng!', 'success');
                            
                            // Listen for account changes
                            window.ethereum.on('accountsChanged', (accounts) => {
                                if (accounts.length > 0) {
                                    this.account = accounts[0];
                                    this.updateWalletUI();
                                } else {
                                    this.disconnect();
                                }
                            });

                            return true;
                        }
                    } else {
                        showNotification('Vui l√≤ng c√†i ƒë·∫∑t MetaMask!', 'error');
                        return false;
                    }
                } catch (error) {
                    console.error('L·ªói k·∫øt n·ªëi v√≠:', error);
                    showNotification('L·ªói k·∫øt n·ªëi v√≠: ' + error.message, 'error');
                    return false;
                }
            }

            async switchToSepolia() {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0xaa36a7' }] // Sepolia testnet chain ID
                    });
                } catch (switchError) {
                    // Chain not added to MetaMask
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xaa36a7',
                                    chainName: 'Sepolia Test Network',
                                    nativeCurrency: {
                                        name: 'Sepolia Ether',
                                        symbol: 'SepoliaETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://sepolia.infura.io/v3/'],
                                    blockExplorerUrls: ['https://sepolia.etherscan.io/']
                                }]
                            });
                        } catch (addError) {
                            console.error('L·ªói th√™m Sepolia network:', addError);
                        }
                    }
                }
            }

            disconnect() {
                this.account = null;
                this.isConnected = false;
                this.updateWalletUI();
                showNotification('ƒê√£ ng·∫Øt k·∫øt n·ªëi v√≠', 'success');
            }

            updateWalletUI() {
                const statusElement = document.getElementById('wallet-status');
                const addressElement = document.getElementById('wallet-address');
                const connectBtn = document.getElementById('connect-wallet');

                if (this.isConnected && this.account) {
                    statusElement.textContent = 'ƒê√£ k·∫øt n·ªëi - Sepolia Network';
                    addressElement.textContent = `${this.account.substring(0, 6)}...${this.account.substring(38)}`;
                    connectBtn.textContent = 'Ng·∫Øt k·∫øt n·ªëi';
                } else {
                    statusElement.textContent = 'Ch∆∞a k·∫øt n·ªëi v√≠';
                    addressElement.textContent = '';
                    connectBtn.textContent = 'K·∫øt n·ªëi MetaMask';
                }
            }

            bindEvents() {
                document.getElementById('connect-wallet').addEventListener('click', () => {
                    if (this.isConnected) {
                        this.disconnect();
                    } else {
                        this.connectWallet();
                    }
                });
            }

            async deployContract() {
                if (!this.isConnected) {
                    showNotification('Vui l√≤ng k·∫øt n·ªëi v√≠ tr∆∞·ªõc!', 'error');
                    return;
                }

                // Simple contract deployment simulation
                try {
                    showNotification('ƒêang deploy smart contract...', 'success');
                    
                    // Simulate contract deployment
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    const contractAddress = '0x' + Math.random().toString(16).substr(2, 40);
                    showNotification(`Contract ƒë√£ deploy th√†nh c√¥ng! Address: ${contractAddress.substring(0, 10)}...`, 'success');
                    
                    return contractAddress;
                } catch (error) {
                    showNotification('L·ªói deploy contract: ' + error.message, 'error');
                    return null;
                }
            }
        }

        // FHE (Fully Homomorphic Encryption) Manager
        class FHEManager {
            constructor() {
                this.isInitialized = false;
                this.encryptedGameState = null;
            }

            async initialize() {
                try {
                    showNotification('ƒêang kh·ªüi t·∫°o FHE...', 'success');
                    
                    // Simulate FHE initialization
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    this.isInitialized = true;
                    document.getElementById('fhe-status').textContent = 'Tr·∫°ng th√°i: ƒê√£ k√≠ch ho·∫°t';
                    showNotification('FHE ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t!', 'success');
                    
                    return true;
                } catch (error) {
                    showNotification('L·ªói kh·ªüi t·∫°o FHE: ' + error.message, 'error');
                    return false;
                }
            }

            encryptMove(move) {
                if (!this.isInitialized) {
                    console.warn('FHE ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o');
                    return move; // Return unencrypted for now
                }

                // Simulate homomorphic encryption
                const encrypted = {
                    data: btoa(JSON.stringify(move)),
                    timestamp: Date.now(),
                    encrypted: true
                };
                
                return encrypted;
            }

            decryptMove(encryptedMove) {
                if (!encryptedMove.encrypted) {
                    return encryptedMove;
                }

                try {
                    const decrypted = JSON.parse(atob(encryptedMove.data));
                    return decrypted;
                } catch (error) {
                    console.error('L·ªói gi·∫£i m√£:', error);
                    return null;
                }
            }

            computeOnEncrypted(encryptedData) {
                // Simulate homomorphic computation
                console.log('Th·ª±c hi·ªán t√≠nh to√°n tr√™n d·ªØ li·ªáu ƒë∆∞·ª£c m√£ h√≥a...');
                return encryptedData;
            }
        }

        // Utility Functions
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 4000);
        }

        function formatAddress(address) {
            return `${address.substring(0, 6)}...${address.substring(38)}`;
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize game and managers
            const chessGame = new ChessGame();
            const web3Manager = new Web3Manager();
            const fheManager = new FHEManager();

            // Add FHE initialization button
            const fheSection = document.querySelector('.fhe-section');
            const fheButton = document.createElement('button');
            fheButton.textContent = 'K√≠ch ho·∫°t FHE';
            fheButton.className = 'connect-btn';
            fheButton.style.marginTop = '10px';
            fheButton.addEventListener('click', () => fheManager.initialize());
            fheSection.appendChild(fheButton);

            // Add deploy contract button
            const deployButton = document.createElement('button');
            deployButton.textContent = 'Deploy Smart Contract';
            deployButton.className = 'connect-btn';
            deployButton.style.marginLeft = '10px';
            deployButton.addEventListener('click', () => web3Manager.deployContract());
            document.querySelector('.wallet-info').appendChild(deployButton);

            // Enhanced game integration with Web3 and FHE
            const originalMakeMove = chessGame.makeMove;
            chessGame.makeMove = function(fromRow, fromCol, toRow, toCol) {
                const move = { fromRow, fromCol, toRow, toCol, timestamp: Date.now() };
                
                // Encrypt move if FHE is enabled
                if (fheManager.isInitialized) {
                    const encryptedMove = fheManager.encryptMove(move);
                    console.log('N∆∞·ªõc ƒëi ƒë√£ ƒë∆∞·ª£c m√£ h√≥a:', encryptedMove);
                }
                
                // Record move on blockchain (simulation)
                if (web3Manager.isConnected) {
                    console.log('Ghi n∆∞·ªõc ƒëi l√™n blockchain...');
                }
                
                // Call original makeMove
                originalMakeMove.call(this, fromRow, fromCol, toRow, toCol);
            };

            // Welcome message
            showNotification('Ch√†o m·ª´ng ƒë·∫øn v·ªõi Chess DApp! K·∫øt n·ªëi v√≠ ƒë·ªÉ b·∫Øt ƒë·∫ßu.', 'success');

            // Auto-connect if previously connected
            if (typeof window.ethereum !== 'undefined') {
                window.ethereum.request({ method: 'eth_accounts' })
                    .then(accounts => {
                        if (accounts.length > 0) {
                            web3Manager.account = accounts[0];
                            web3Manager.isConnected = true;
                            web3Manager.updateWalletUI();
                        }
                    })
                    .catch(console.error);
            }
        });

        // Service Worker for PWA (Progressive Web App)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => console.log('SW registered:', registration))
                    .catch(registrationError => console.log('SW registration failed:', registrationError));
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'n':
                        e.preventDefault();
                        document.getElementById('new-game').click();
                        break;
                    case 'c':
                        e.preventDefault();
                        document.getElementById('connect-wallet').click();
                        break;
                }
            }
        });

        // Performance monitoring
        const performanceObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'measure') {
                    console.log(`${entry.name}: ${entry.duration}ms`);
                }
            }
        });
        
        if (typeof PerformanceObserver !== 'undefined') {
            performanceObserver.observe({ entryTypes: ['measure'] });
        }

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Application error:', e.error);
            showNotification('C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            showNotification('C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω y√™u c·∫ßu.', 'error');
        });
    </script>
</body>
</html>