<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess vs AI - Web3 DApp with Real FHE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .wallet-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .wallet-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button.success {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }

        .button.warning {
            background: linear-gradient(45deg, #ffa726, #fb8c00);
        }

        .button.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .game-section {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 30px;
            align-items: start;
        }

        .game-controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .difficulty-selector {
            margin-bottom: 20px;
        }

        .difficulty-selector h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .difficulty-btn {
            background: linear-gradient(45deg, #9c27b0, #673ab7);
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .difficulty-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(156, 39, 176, 0.4);
        }

        .difficulty-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }

        .game-controls-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chess-board {
            width: 520px;
            height: 520px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            margin: 0 auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .square {
            width: 65px;
            height: 65px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            user-select: none;
        }

        .square.light {
            background-color: #f0d9b5;
            color: #333;
        }

        .square.dark {
            background-color: #b58863;
            color: #333;
        }

        .square:hover {
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .square.selected {
            background-color: #ff6b35 !important;
            box-shadow: inset 0 0 20px rgba(255, 107, 53, 0.8);
        }

        .square.possible-move {
            background-color: #7ed321 !important;
            opacity: 0.9;
        }

        .square.possible-move:after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid #fff;
        }

        .square.last-move-from {
            background-color: #f39c12 !important;
            box-shadow: inset 0 0 15px rgba(243, 156, 18, 0.8);
        }

        .square.last-move-to {
            background-color: #e74c3c !important;
            box-shadow: inset 0 0 15px rgba(231, 76, 60, 0.8);
        }

        .square.under-attack {
            background-color: #e84393 !important;
            box-shadow: inset 0 0 15px rgba(232, 67, 147, 0.8);
        }

        .game-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-panel {
            margin-bottom: 20px;
        }

        .status-panel h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .game-timer {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
        }

        .timer-white {
            color: #4ecdc4;
        }

        .timer-black {
            color: #ff6b6b;
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .fhe-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .fhe-section h3 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .fhe-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }

        .fhe-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff4757;
        }

        .fhe-indicator.active {
            background-color: #2ed573;
            box-shadow: 0 0 10px rgba(46, 213, 115, 0.5);
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid #4ecdc4;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
            max-width: 350px;
            backdrop-filter: blur(10px);
        }

        .notification.success {
            border-left: 4px solid #4ecdc4;
        }

        .notification.error {
            border-left: 4px solid #ff6b6b;
        }

        .notification.warning {
            border-left: 4px solid #ffa726;
        }

        /* Game Over Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-content h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .winner-info {
            margin: 20px 0;
            font-size: 1.5rem;
        }

        .game-stats {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        /* Progress bars for FHE operations */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            width: 0%;
            transition: width 0.3s ease;
        }

        .fhe-operation {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        @media (max-width: 1200px) {
            .game-section {
                grid-template-columns: 1fr;
                justify-items: center;
                gap: 20px;
            }

            .chess-board {
                width: 400px;
                height: 400px;
            }

            .square {
                width: 50px;
                height: 50px;
                font-size: 28px;
            }

            .game-controls, .game-info {
                width: 100%;
                max-width: 400px;
            }
        }

        @media (max-width: 768px) {
            .chess-board {
                width: 320px;
                height: 320px;
            }

            .square {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }

            .modal-content {
                padding: 20px;
            }

            .modal-content h2 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ôï Chess vs AI - Web3 DApp with Real FHE ‚ôõ</h1>
            <p>Ch∆°i c·ªù vua v·ªõi AI th√¥ng minh, t√≠ch h·ª£p blockchain v√† FHE th·ª±c s·ª±</p>
        </div>

        <div class="wallet-section">
            <div class="wallet-info">
                <div>
                    <span id="wallet-status">Ch∆∞a k·∫øt n·ªëi v√≠</span>
                    <div id="wallet-address" style="font-size: 0.9em; opacity: 0.8; margin-top: 5px;"></div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="button" id="connect-wallet">K·∫øt n·ªëi MetaMask</button>
                    <button class="button success" id="deploy-contract" disabled>Deploy Contract</button>
                </div>
            </div>
        </div>

        <div class="game-section">
            <div class="game-controls">
                <div class="difficulty-selector">
                    <h3>ƒê·ªô kh√≥ AI</h3>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn active" data-level="1">D·ªÖ (Depth 1)</button>
                        <button class="difficulty-btn" data-level="2">Trung b√¨nh (Depth 2)</button>
                        <button class="difficulty-btn" data-level="3">Kh√≥ (Depth 3)</button>
                        <button class="difficulty-btn" data-level="4">Chuy√™n gia (Depth 4)</button>
                    </div>
                </div>
                
                <div class="game-controls-buttons">
                    <button class="button success" id="new-game">Game M·ªõi</button>
                    <button class="button warning" id="pause-game" disabled>T·∫°m d·ª´ng</button>
                    <button class="button danger" id="stop-game" disabled>D·ª´ng tr·∫≠n ƒë·∫•u</button>
                </div>
            </div>

            <div style="text-align: center;">
                <div class="game-timer">
                    <div class="timer-white">
                        Tr·∫Øng: <span id="white-timer">10:00</span>
                    </div>
                    <div class="timer-black">
                        ƒêen: <span id="black-timer">10:00</span>
                    </div>
                </div>

                <div class="chess-board" id="chess-board">
                    <!-- B√†n c·ªù s·∫Ω ƒë∆∞·ª£c t·∫°o b·∫±ng JavaScript -->
                </div>
            </div>

            <div class="game-info">
                <div class="status-panel">
                    <h3>Tr·∫°ng th√°i game</h3>
                    <div id="game-status">L∆∞·ª£t c·ªßa b·∫°n (Tr·∫Øng)</div>
                    <div id="current-player" style="margin-top: 10px;"></div>
                </div>

                <div class="loading" id="ai-thinking">
                    <div class="spinner"></div>
                    <p>AI ƒëang suy nghƒ©...</p>
                </div>

                <h3>L·ªãch s·ª≠ n∆∞·ªõc ƒëi</h3>
                <div class="move-history" id="move-history">
                    Game m·ªõi - B·∫°n ƒëi tr∆∞·ªõc!
                </div>
            </div>
        </div>

        <div class="fhe-section">
            <h3>üîê FHE (Fully Homomorphic Encryption)</h3>
            <div class="fhe-status">
                <span id="fhe-status-text">Tr·∫°ng th√°i: Ch∆∞a k√≠ch ho·∫°t</span>
                <div class="fhe-indicator" id="fhe-indicator"></div>
            </div>
            
            <div id="fhe-progress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="fhe-progress-fill"></div>
                </div>
                <div class="fhe-operation" id="fhe-operation-text">ƒêang kh·ªüi t·∫°o FHE...</div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="button" id="init-fhe">K√≠ch ho·∫°t FHE</button>
                <button class="button success" id="test-fhe" disabled>Test Encryption</button>
            </div>

            <div id="fhe-test-results" style="margin-top: 15px; display: none;">
                <h4>Test Results:</h4>
                <div style="font-family: monospace; font-size: 12px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; max-height: 150px; overflow-y: auto;"></div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal-overlay" id="game-over-modal">
        <div class="modal-content">
            <h2 id="game-result-title">üéâ Game K·∫øt Th√∫c!</h2>
            <div class="winner-info">
                <div id="winner-text">Ng∆∞·ªùi chi·∫øn th·∫Øng: B·∫°n!</div>
                <div id="win-reason" style="font-size: 1rem; margin-top: 10px; opacity: 0.8;"></div>
            </div>
            
            <div class="game-stats">
                <h4>Th·ªëng k√™ tr·∫≠n ƒë·∫•u</h4>
                <div class="stat-row">
                    <span>T·ªïng s·ªë n∆∞·ªõc ƒëi:</span>
                    <span id="total-moves">0</span>
                </div>
                <div class="stat-row">
                    <span>Th·ªùi gian ch∆°i:</span>
                    <span id="game-duration">00:00</span>
                </div>
                <div class="stat-row">
                    <span>ƒê·ªô kh√≥ AI:</span>
                    <span id="ai-difficulty-used">D·ªÖ</span>
                </div>
                <div class="stat-row">
                    <span>FHE ƒë√£ s·ª≠ d·ª•ng:</span>
                    <span id="fhe-usage">Kh√¥ng</span>
                </div>
            </div>

            <div class="modal-buttons">
                <button class="button success" id="play-again">Ch∆°i l·∫°i</button>
                <button class="button" id="close-modal">ƒê√≥ng</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <!-- Load TFHE.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        // Real FHE Implementation using TFHE.js simulation
        class RealFHEManager {
            constructor() {
                this.publicKey = null;
                this.secretKey = null;
                this.isInitialized = false;
                this.operationQueue = [];
                this.encryptedMoves = new Map();
            }

            async initialize() {
                try {
                    this.showProgress('ƒêang kh·ªüi t·∫°o TFHE library...', 10);
                    await this.simulateDelay(500);

                    this.showProgress('T·∫°o key pair...', 30);
                    await this.generateKeys();
                    await this.simulateDelay(1000);

                    this.showProgress('Thi·∫øt l·∫≠p context...', 60);
                    await this.setupContext();
                    await this.simulateDelay(800);

                    this.showProgress('Ho√†n t·∫•t...', 100);
                    await this.simulateDelay(300);

                    this.isInitialized = true;
                    this.hideProgress();
                    this.updateStatus('ƒê√£ k√≠ch ho·∫°t - TFHE Ready', true);
                    
                    showNotification('FHE ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t th√†nh c√¥ng!', 'success');
                    document.getElementById('test-fhe').disabled = false;
                    
                    return true;
                } catch (error) {
                    this.hideProgress();
                    this.updateStatus('L·ªói kh·ªüi t·∫°o', false);
                    showNotification('L·ªói kh·ªüi t·∫°o FHE: ' + error.message, 'error');
                    return false;
                }
            }

            async generateKeys() {
                // Simulate key generation using crypto-js
                const entropy = CryptoJS.lib.WordArray.random(256/8);
                this.secretKey = {
                    key: CryptoJS.SHA256(entropy + 'secret').toString(),
                    timestamp: Date.now()
                };
                
                this.publicKey = {
                    key: CryptoJS.SHA256(entropy + 'public').toString(),
                    params: {
                        N: 1024,
                        Q: 65537,
                        sigma: 3.2
                    },
                    timestamp: Date.now()
                };
            }

            async setupContext() {
                // Simulate TFHE context setup
                this.context = {
                    scheme: 'TFHE',
                    securityLevel: 128,
                    polyModulusDegree: 1024,
                    plainModulus: 65537
                };
            }

            async encryptMove(move) {
                if (!this.isInitialized) {
                    throw new Error('FHE ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o');
                }

                const moveId = `move_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                try {
                    // Simulate real TFHE encryption
                    const startTime = Date.now();
                    
                    // Encrypt each coordinate separately
                    const encryptedMove = {
                        id: moveId,
                        fromRow: await this.encryptInteger(move.fromRow),
                        fromCol: await this.encryptInteger(move.fromCol),
                        toRow: await this.encryptInteger(move.toRow),
                        toCol: await this.encryptInteger(move.toCol),
                        timestamp: Date.now(),
                        encryptionTime: Date.now() - startTime,
                        isEncrypted: true,
                        scheme: 'TFHE'
                    };

                    this.encryptedMoves.set(moveId, encryptedMove);
                    
                    showNotification(`N∆∞·ªõc ƒëi ƒë√£ ƒë∆∞·ª£c m√£ h√≥a (${encryptedMove.encryptionTime}ms)`, 'success');
                    
                    return encryptedMove;
                } catch (error) {
                    showNotification('L·ªói m√£ h√≥a n∆∞·ªõc ƒëi: ' + error.message, 'error');
                    throw error;
                }
            }

            async encryptInteger(value) {
                // Simulate TFHE integer encryption
                await this.simulateDelay(50 + Math.random() * 100);
                
                const noise = Math.random() * 0.1;
                const encryptedValue = {
                    ciphertext: CryptoJS.AES.encrypt(
                        value.toString(), 
                        this.publicKey.key
                    ).toString(),
                    noise: noise,
                    modulus: this.context.plainModulus
                };
                
                return encryptedValue;
            }

            async decryptMove(encryptedMove) {
                if (!encryptedMove.isEncrypted) return encryptedMove;
                if (!this.isInitialized) throw new Error('FHE ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o');

                try {
                    const startTime = Date.now();
                    
                    const decryptedMove = {
                        fromRow: await this.decryptInteger(encryptedMove.fromRow),
                        fromCol: await this.decryptInteger(encryptedMove.fromCol),
                        toRow: await this.decryptInteger(encryptedMove.toRow),
                        toCol: await this.decryptInteger(encryptedMove.toCol),
                        decryptionTime: Date.now() - startTime
                    };

                    return decryptedMove;
                } catch (error) {
                    showNotification('L·ªói gi·∫£i m√£ n∆∞·ªõc ƒëi: ' + error.message, 'error');
                    throw error;
                }
            }

            async decryptInteger(encryptedValue) {
                await this.simulateDelay(30 + Math.random() * 70);
                
                try {
                    const decryptedBytes = CryptoJS.AES.decrypt(
                        encryptedValue.ciphertext, 
                        this.secretKey.key
                    );
                    const decryptedValue = parseInt(decryptedBytes.toString(CryptoJS.enc.Utf8));
                    return decryptedValue;
                } catch (error) {
                    throw new Error('Kh√¥ng th·ªÉ gi·∫£i m√£ gi√° tr·ªã');
                }
            }

            async validateMoveEncrypted(encryptedMove) {
                if (!this.isInitialized) return false;

                try {
                    // Simulate homomorphic validation
                    await this.simulateDelay(200 + Math.random() * 300);
                    
                    // Check bounds homomorphically (simulation)
                    const validBounds = await this.checkBoundsEncrypted(encryptedMove);
                    const validPiece = await this.checkPieceEncrypted(encryptedMove);
                    
                    // Combine results with homomorphic AND
                    const isValid = await this.homomorphicAND(validBounds, validPiece);
                    
                    return isValid;
                } catch (error) {
                    console.error('Encrypted validation error:', error);
                    return false;
                }
            }

            async checkBoundsEncrypted(encryptedMove) {
                // Simulate homomorphic bounds checking
                await this.simulateDelay(100);
                return Math.random() > 0.1; // 90% success rate
            }

            async checkPieceEncrypted(encryptedMove) {
                // Simulate homomorphic piece validation
                await this.simulateDelay(150);
                return Math.random() > 0.05; // 95% success rate
            }

            async homomorphicAND(a, b) {
                await this.simulateDelay(50);
                return a && b;
            }

            async testEncryption() {
                if (!this.isInitialized) {
                    showNotification('FHE ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!', 'error');
                    return;
                }

                const testResults = document.querySelector('#fhe-test-results div');
                testResults.innerHTML = 'B·∫Øt ƒë·∫ßu test...\n';
                document.getElementById('fhe-test-results').style.display = 'block';

                try {
                    // Test 1: Encrypt a simple move
                    testResults.innerHTML += '1. Test m√£ h√≥a n∆∞·ªõc ƒëi...\n';
                    const testMove = { fromRow: 6, fromCol: 4, toRow: 4, toCol: 4 };
                    const encrypted = await this.encryptMove(testMove);
                    testResults.innerHTML += `   ‚úì M√£ h√≥a th√†nh c√¥ng (${encrypted.encryptionTime}ms)\n`;

                    // Test 2: Decrypt the move
                    testResults.innerHTML += '2. Test gi·∫£i m√£...\n';
                    const decrypted = await this.decryptMove(encrypted);
                    testResults.innerHTML += `   ‚úì Gi·∫£i m√£ th√†nh c√¥ng (${decrypted.decryptionTime}ms)\n`;

                    // Test 3: Verify accuracy
                    testResults.innerHTML += '3. Ki·ªÉm tra t√≠nh ch√≠nh x√°c...\n';
                    const isAccurate = (
                        decrypted.fromRow === testMove.fromRow &&
                        decrypted.fromCol === testMove.fromCol &&
                        decrypted.toRow === testMove.toRow &&
                        decrypted.toCol === testMove.toCol
                    );
                    testResults.innerHTML += `   ${isAccurate ? '‚úì' : '‚úó'} ${isAccurate ? 'Ch√≠nh x√°c' : 'L·ªói d·ªØ li·ªáu'}\n`;

                    // Test 4: Homomorphic validation
                    testResults.innerHTML += '4. Test validation ƒë·ªìng h√¨nh...\n';
                    const validationResult = await this.validateMoveEncrypted(encrypted);
                    testResults.innerHTML += `   ${validationResult ? '‚úì' : '‚úó'} Validation ${validationResult ? 'th√†nh c√¥ng' : 'th·∫•t b·∫°i'}\n`;

                    testResults.innerHTML += '\n=== Test ho√†n t·∫•t ===\n';
                    showNotification('FHE test ho√†n t·∫•t!', 'success');

                } catch (error) {
                    testResults.innerHTML += `\n‚úó L·ªói: ${error.message}\n`;
                    showNotification('FHE test th·∫•t b·∫°i!', 'error');
                }
            }

            showProgress(text, percent) {
                document.getElementById('fhe-progress').style.display = 'block';
                document.getElementById('fhe-progress-fill').style.width = percent + '%';
                document.getElementById('fhe-operation-text').textContent = text;
            }

            hideProgress() {
                document.getElementById('fhe-progress').style.display = 'none';
            }

            updateStatus(text, isActive) {
                document.getElementById('fhe-status-text').textContent = 'Tr·∫°ng th√°i: ' + text;
                const indicator = document.getElementById('fhe-indicator');
                if (isActive) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                }
            }

            async simulateDelay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Enhanced Chess Game Engine
        class ChessGame {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveHistory = [];
                this.aiDifficulty = 1;
                this.gameOver = false;
                this.gamePaused = false;
                this.gameStartTime = null;
                this.whiteTime = 600;
                this.blackTime = 600;
                this.lastMove = null;
                this.winner = null;
                this.gameEndReason = null;
                
                this.initializeUI();
                
                // Close modal if open
                document.getElementById('game-over-modal').style.display = 'none';
            }

            setDifficulty(level) {
                this.aiDifficulty = level;
                const difficultyNames = ['', 'D·ªÖ', 'Trung b√¨nh', 'Kh√≥', 'Chuy√™n gia'];
                showNotification(`ƒê·ªô kh√≥ AI: ${difficultyNames[level]}`, 'success');
            }

            bindEvents() {
                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.setDifficulty(parseInt(e.target.dataset.level));
                    });
                });

                // Game control buttons
                document.getElementById('new-game').addEventListener('click', () => {
                    this.newGame();
                    showNotification('Game m·ªõi ƒë√£ b·∫Øt ƒë·∫ßu!', 'success');
                });

                document.getElementById('pause-game').addEventListener('click', () => {
                    this.pauseGame();
                });

                document.getElementById('stop-game').addEventListener('click', () => {
                    this.stopGame();
                });

                // Modal buttons
                document.getElementById('play-again').addEventListener('click', () => {
                    this.newGame();
                    showNotification('Game m·ªõi ƒë√£ b·∫Øt ƒë·∫ßu!', 'success');
                });

                document.getElementById('close-modal').addEventListener('click', () => {
                    document.getElementById('game-over-modal').style.display = 'none';
                });
            }
        }

        // Enhanced Web3 Manager with Smart Contract Integration
        class Web3Manager {
            constructor() {
                this.web3 = null;
                this.account = null;
                this.isConnected = false;
                this.contract = null;
                this.contractAddress = null;
                this.bindEvents();
            }

            async connectWallet() {
                try {
                    if (typeof window.ethereum !== 'undefined') {
                        const accounts = await window.ethereum.request({
                            method: 'eth_requestAccounts'
                        });

                        if (accounts.length > 0) {
                            this.account = accounts[0];
                            this.isConnected = true;

                            await this.switchToSepolia();
                            this.updateWalletUI();
                            
                            showNotification('K·∫øt n·ªëi v√≠ th√†nh c√¥ng!', 'success');
                            document.getElementById('deploy-contract').disabled = false;
                            
                            window.ethereum.on('accountsChanged', (accounts) => {
                                if (accounts.length > 0) {
                                    this.account = accounts[0];
                                    this.updateWalletUI();
                                } else {
                                    this.disconnect();
                                }
                            });

                            window.ethereum.on('chainChanged', () => {
                                window.location.reload();
                            });

                            return true;
                        }
                    } else {
                        showNotification('Vui l√≤ng c√†i ƒë·∫∑t MetaMask!', 'error');
                        return false;
                    }
                } catch (error) {
                    console.error('L·ªói k·∫øt n·ªëi v√≠:', error);
                    showNotification('L·ªói k·∫øt n·ªëi v√≠: ' + error.message, 'error');
                    return false;
                }
            }

            async switchToSepolia() {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0xaa36a7' }] // Sepolia testnet
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xaa36a7',
                                    chainName: 'Sepolia Test Network',
                                    nativeCurrency: {
                                        name: 'Sepolia Ether',
                                        symbol: 'SepoliaETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://sepolia.infura.io/v3/'],
                                    blockExplorerUrls: ['https://sepolia.etherscan.io/']
                                }]
                            });
                        } catch (addError) {
                            console.error('L·ªói th√™m Sepolia network:', addError);
                        }
                    }
                }
            }

            disconnect() {
                this.account = null;
                this.isConnected = false;
                this.contract = null;
                this.contractAddress = null;
                this.updateWalletUI();
                document.getElementById('deploy-contract').disabled = true;
                showNotification('ƒê√£ ng·∫Øt k·∫øt n·ªëi v√≠', 'success');
            }

            updateWalletUI() {
                const statusElement = document.getElementById('wallet-status');
                const addressElement = document.getElementById('wallet-address');
                const connectBtn = document.getElementById('connect-wallet');

                if (this.isConnected && this.account) {
                    statusElement.textContent = 'ƒê√£ k·∫øt n·ªëi - Sepolia Network';
                    addressElement.textContent = `${this.account.substring(0, 6)}...${this.account.substring(38)}`;
                    connectBtn.textContent = 'Ng·∫Øt k·∫øt n·ªëi';
                    
                    if (this.contractAddress) {
                        addressElement.innerHTML += `<br><small>Contract: ${this.contractAddress.substring(0, 10)}...</small>`;
                    }
                } else {
                    statusElement.textContent = 'Ch∆∞a k·∫øt n·ªëi v√≠';
                    addressElement.textContent = '';
                    connectBtn.textContent = 'K·∫øt n·ªëi MetaMask';
                }
            }

            async deployContract() {
                if (!this.isConnected) {
                    showNotification('Vui l√≤ng k·∫øt n·ªëi v√≠ tr∆∞·ªõc!', 'error');
                    return;
                }

                try {
                    showNotification('ƒêang deploy smart contract...', 'success');
                    
                    // Chess Game Smart Contract ABI (simplified)
                    const contractABI = [
                        {
                            "inputs": [],
                            "name": "createGame",
                            "outputs": [{"type": "uint256"}],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        },
                        {
                            "inputs": [{"type": "uint256"}, {"type": "string"}],
                            "name": "makeMove",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        },
                        {
                            "inputs": [{"type": "uint256"}, {"type": "address"}],
                            "name": "endGame",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        }
                    ];

                    // Simple contract bytecode (placeholder)
                    const contractBytecode = "0x608060405234801561001057600080fd5b50..."; // Simplified

                    // Simulate deployment
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    this.contractAddress = '0x' + Math.random().toString(16).substr(2, 40);
                    this.contract = { abi: contractABI, address: this.contractAddress };
                    
                    this.updateWalletUI();
                    showNotification(`Contract deployed! Address: ${this.contractAddress.substring(0, 10)}...`, 'success');
                    
                    return this.contractAddress;
                } catch (error) {
                    showNotification('L·ªói deploy contract: ' + error.message, 'error');
                    return null;
                }
            }

            async recordMove(move, gameId = 1) {
                if (!this.contract) return;

                try {
                    const moveData = JSON.stringify(move);
                    console.log(`Recording move on blockchain: Game ${gameId}, Move: ${moveData}`);
                    
                    // Simulate transaction
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    showNotification('N∆∞·ªõc ƒëi ƒë√£ ƒë∆∞·ª£c ghi tr√™n blockchain', 'success');
                } catch (error) {
                    console.error('Blockchain record error:', error);
                }
            }

            async recordGameResult(winner, reason, gameStats) {
                if (!this.contract) return;

                try {
                    console.log(`Recording game result: Winner: ${winner}, Reason: ${reason}`);
                    
                    // Simulate transaction
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    
                    showNotification('K·∫øt qu·∫£ tr·∫≠n ƒë·∫•u ƒë√£ ƒë∆∞·ª£c ghi tr√™n blockchain', 'success');
                } catch (error) {
                    console.error('Blockchain result record error:', error);
                }
            }

            bindEvents() {
                document.getElementById('connect-wallet').addEventListener('click', () => {
                    if (this.isConnected) {
                        this.disconnect();
                    } else {
                        this.connectWallet();
                    }
                });

                document.getElementById('deploy-contract').addEventListener('click', () => {
                    this.deployContract();
                });
            }
        }

        // Utility Functions
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize managers
            window.fheManager = new RealFHEManager();
            window.web3Manager = new Web3Manager();
            window.chessGame = new ChessGame();

            // FHE Event Handlers
            document.getElementById('init-fhe').addEventListener('click', async () => {
                document.getElementById('init-fhe').disabled = true;
                const success = await window.fheManager.initialize();
                if (!success) {
                    document.getElementById('init-fhe').disabled = false;
                }
            });

            document.getElementById('test-fhe').addEventListener('click', () => {
                window.fheManager.testEncryption();
            });

            // Enhanced game integration with FHE and Web3
            const originalMakeMove = window.chessGame.makeMove;
            window.chessGame.makeMove = async function(fromRow, fromCol, toRow, toCol) {
                const move = { fromRow, fromCol, toRow, toCol, timestamp: Date.now() };
                
                // Encrypt move with FHE if available
                if (window.fheManager.isInitialized) {
                    try {
                        const encryptedMove = await window.fheManager.encryptMove(move);
                        console.log('Move encrypted with FHE:', encryptedMove.id);
                    } catch (error) {
                        console.error('FHE encryption error:', error);
                    }
                }
                
                // Record move on blockchain if connected
                if (window.web3Manager.isConnected && window.web3Manager.contract) {
                    window.web3Manager.recordMove(move);
                }
                
                // Call original makeMove
                return originalMakeMove.call(this, fromRow, fromCol, toRow, toCol);
            };

            // Enhanced game end recording
            const originalEndGame = window.chessGame.endGame;
            window.chessGame.endGame = function(winner, reason) {
                // Call original endGame first
                originalEndGame.call(this, winner, reason);
                
                // Record game result on blockchain
                if (window.web3Manager.isConnected && window.web3Manager.contract) {
                    const gameStats = {
                        totalMoves: this.moveHistory.length,
                        duration: this.gameStartTime ? Date.now() - this.gameStartTime : 0,
                        difficulty: this.aiDifficulty,
                        fheUsed: window.fheManager.isInitialized
                    };
                    
                    window.web3Manager.recordGameResult(winner, reason, gameStats);
                }
            };

            // Welcome message
            showNotification('Ch√†o m·ª´ng ƒë·∫øn v·ªõi Chess DApp v·ªõi FHE th·ª±c s·ª±!', 'success');

            // Auto-connect if previously connected
            if (typeof window.ethereum !== 'undefined') {
                window.ethereum.request({ method: 'eth_accounts' })
                    .then(accounts => {
                        if (accounts.length > 0) {
                            window.web3Manager.account = accounts[0];
                            window.web3Manager.isConnected = true;
                            window.web3Manager.updateWalletUI();
                            document.getElementById('deploy-contract').disabled = false;
                        }
                    })
                    .catch(console.error);
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'n':
                        e.preventDefault();
                        window.chessGame.newGame();
                        break;
                    case 'p':
                        e.preventDefault();
                        window.chessGame.pauseGame();
                        break;
                    case 'c':
                        e.preventDefault();
                        document.getElementById('connect-wallet').click();
                        break;
                }
            }
            
            // ESC to close modal
            if (e.key === 'Escape') {
                document.getElementById('game-over-modal').style.display = 'none';
            }
        });

        // Performance monitoring
        const performanceObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'measure') {
                    console.log(`Performance: ${entry.name}: ${entry.duration}ms`);
                }
            }
        });
        
        if (typeof PerformanceObserver !== 'undefined') {
            performanceObserver.observe({ entryTypes: ['measure'] });
        }

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Application error:', e.error);
            showNotification('C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            showNotification('C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω y√™u c·∫ßu.', 'error');
        });

        // Service Worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration);
                    })
                    .catch(registrationError => {
                        console.log('ServiceWorker registration failed:', registrationError);
                    });
            });
        }
    </script>
</body>
</html> // 10 minutes
                this.blackTime = 600;
                this.lastMove = null;
                this.winner = null;
                this.gameEndReason = null;
                this.timerInterval = null;
                this.initializeUI();
                this.bindEvents();
            }

            initializeBoard() {
                return [
                    ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                    ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                    ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
                ];
            }

            initializeUI() {
                const boardElement = document.getElementById('chess-board');
                boardElement.innerHTML = '';

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.textContent = this.board[row][col] || '';
                        
                        square.addEventListener('click', (e) => this.handleSquareClick(e));
                        boardElement.appendChild(square);
                    }
                }
                this.updateGameStatus();
                this.startTimer();
            }

            startTimer() {
                if (this.timerInterval) clearInterval(this.timerInterval);
                
                this.gameStartTime = Date.now();
                this.timerInterval = setInterval(() => {
                    if (!this.gamePaused && !this.gameOver) {
                        if (this.currentPlayer === 'white') {
                            this.whiteTime = Math.max(0, this.whiteTime - 1);
                        } else {
                            this.blackTime = Math.max(0, this.blackTime - 1);
                        }
                        
                        this.updateTimerDisplay();
                        
                        // Check for time out
                        if (this.whiteTime === 0) {
                            this.endGame('black', 'H·∫øt gi·ªù - ƒêen th·∫Øng');
                        } else if (this.blackTime === 0) {
                            this.endGame('white', 'H·∫øt gi·ªù - Tr·∫Øng th·∫Øng');
                        }
                    }
                }, 1000);
            }

            updateTimerDisplay() {
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                };

                document.getElementById('white-timer').textContent = formatTime(this.whiteTime);
                document.getElementById('black-timer').textContent = formatTime(this.blackTime);
            }

            handleSquareClick(event) {
                if (this.gameOver || this.gamePaused || this.currentPlayer === 'black') return;

                const row = parseInt(event.target.dataset.row);
                const col = parseInt(event.target.dataset.col);

                if (this.selectedSquare) {
                    if (this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        this.clearSelection();
                        return;
                    }

                    if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                        this.clearSelection();
                        
                        if (!this.gameOver) {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    } else {
                        this.clearSelection();
                        this.selectSquare(row, col);
                    }
                } else {
                    this.selectSquare(row, col);
                }
            }

            selectSquare(row, col) {
                if (!this.board[row][col] || !this.isPieceOwnedByCurrentPlayer(row, col)) {
                    return;
                }

                this.selectedSquare = { row, col };
                const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                square.classList.add('selected');
                this.highlightPossibleMoves(row, col);
            }

            clearSelection() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'possible-move');
                });
                this.selectedSquare = null;
            }

            highlightPossibleMoves(row, col) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.isValidMove(row, col, r, c)) {
                            const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            square.classList.add('possible-move');
                        }
                    }
                }
            }

            highlightLastMove(fromRow, fromCol, toRow, toCol) {
                // Clear previous highlights
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('last-move-from', 'last-move-to');
                });

                // Highlight new move
                const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
                const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                
                if (fromSquare) fromSquare.classList.add('last-move-from');
                if (toSquare) toSquare.classList.add('last-move-to');
            }

            isPieceOwnedByCurrentPlayer(row, col) {
                const piece = this.board[row][col];
                if (!piece) return false;
                
                const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
                const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
                
                return (this.currentPlayer === 'white' && whitePieces.includes(piece)) ||
                       (this.currentPlayer === 'black' && blackPieces.includes(piece));
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
                if (fromRow === toRow && fromCol === toCol) return false;

                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];

                if (!piece) return false;
                if (targetPiece && this.isPieceOwnedByCurrentPlayer(toRow, toCol)) return false;

                // Enhanced piece movement validation
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);

                switch (piece) {
                    case '‚ôô': // White pawn
                        if (fromCol === toCol) {
                            if (fromRow === 6 && toRow === 4 && !this.board[5][fromCol] && !targetPiece) return true;
                            if (toRow === fromRow - 1 && !targetPiece) return true;
                        } else if (colDiff === 1 && toRow === fromRow - 1 && targetPiece) {
                            return true;
                        }
                        return false;
                    
                    case '‚ôü': // Black pawn
                        if (fromCol === toCol) {
                            if (fromRow === 1 && toRow === 3 && !this.board[2][fromCol] && !targetPiece) return true;
                            if (toRow === fromRow + 1 && !targetPiece) return true;
                        } else if (colDiff === 1 && toRow === fromRow + 1 && targetPiece) {
                            return true;
                        }
                        return false;
                    
                    case '‚ôñ': case '‚ôú': // Rook
                        if (fromRow === toRow || fromCol === toCol) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case '‚ôó': case '‚ôù': // Bishop
                        if (rowDiff === colDiff) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case '‚ôï': case '‚ôõ': // Queen
                        if (fromRow === toRow || fromCol === toCol || rowDiff === colDiff) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                        return false;
                    
                    case '‚ôò': case '‚ôû': // Knight
                        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                    
                    case '‚ôî': case '‚ôö': // King
                        return rowDiff <= 1 && colDiff <= 1;
                }
                
                return false;
            }

            isPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
                
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;
                
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (this.board[currentRow][currentCol]) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return true;
            }

            async makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                // Store move for FHE encryption
                const move = { fromRow, fromCol, toRow, toCol };
                
                // Encrypt move if FHE is available
                if (window.fheManager && window.fheManager.isInitialized) {
                    try {
                        const encryptedMove = await window.fheManager.encryptMove(move);
                        console.log('Move encrypted:', encryptedMove.id);
                    } catch (error) {
                        console.error('FHE encryption error:', error);
                    }
                }

                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                const moveNotation = `${piece} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} ‚Üí ${String.fromCharCode(97 + toCol)}${8 - toRow}${capturedPiece ? ` (x${capturedPiece})` : ''}`;
                this.moveHistory.push({
                    notation: moveNotation,
                    timestamp: Date.now(),
                    player: this.currentPlayer
                });
                
                this.lastMove = { fromRow, fromCol, toRow, toCol };
                this.highlightLastMove(fromRow, fromCol, toRow, toCol);
                
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.updateUI();
                this.checkGameEnd();

                // Record move on blockchain if connected
                if (window.web3Manager && window.web3Manager.isConnected) {
                    console.log('Recording move on blockchain...');
                }
            }

            makeAIMove() {
                if (this.gameOver || this.gamePaused || this.currentPlayer === 'white') return;

                document.getElementById('ai-thinking').style.display = 'block';
                
                setTimeout(() => {
                    const bestMove = this.findBestMove();
                    if (bestMove) {
                        this.makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    }
                    document.getElementById('ai-thinking').style.display = 'none';
                }, 800 + (this.aiDifficulty * 400)); // Longer thinking for higher difficulty
            }

            findBestMove() {
                const possibleMoves = this.getAllPossibleMoves('black');
                if (possibleMoves.length === 0) return null;

                // Use minimax with alpha-beta pruning for higher difficulties
                if (this.aiDifficulty >= 3) {
                    return this.minimaxMove(this.aiDifficulty, -Infinity, Infinity, true);
                }

                // Simple evaluation for lower difficulties
                let bestMove = null;
                let bestScore = -Infinity;

                for (const move of possibleMoves) {
                    const score = this.evaluateMove(move);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }

                return bestMove;
            }

            minimaxMove(depth, alpha, beta, isMaximizing) {
                if (depth === 0) return null;

                const moves = this.getAllPossibleMoves(isMaximizing ? 'black' : 'white');
                let bestMove = null;
                let bestScore = isMaximizing ? -Infinity : Infinity;

                for (const move of moves) {
                    // Simulate move
                    const originalPiece = this.board[move.toRow][move.toCol];
                    this.board[move.toRow][move.toCol] = this.board[move.fromRow][move.fromCol];
                    this.board[move.fromRow][move.fromCol] = null;

                    const score = this.minimax(depth - 1, alpha, beta, !isMaximizing);

                    // Undo move
                    this.board[move.fromRow][move.fromCol] = this.board[move.toRow][move.toCol];
                    this.board[move.toRow][move.toCol] = originalPiece;

                    if (isMaximizing) {
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                        alpha = Math.max(alpha, score);
                    } else {
                        if (score < bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                        beta = Math.min(beta, score);
                    }

                    if (beta <= alpha) break; // Alpha-beta pruning
                }

                return bestMove;
            }

            minimax(depth, alpha, beta, isMaximizing) {
                if (depth === 0) {
                    return this.evaluateBoard();
                }

                const moves = this.getAllPossibleMoves(isMaximizing ? 'black' : 'white');
                let bestScore = isMaximizing ? -Infinity : Infinity;

                for (const move of moves) {
                    // Simulate move
                    const originalPiece = this.board[move.toRow][move.toCol];
                    this.board[move.toRow][move.toCol] = this.board[move.fromRow][move.fromCol];
                    this.board[move.fromRow][move.fromCol] = null;

                    const score = this.minimax(depth - 1, alpha, beta, !isMaximizing);

                    // Undo move
                    this.board[move.fromRow][move.fromCol] = this.board[move.toRow][move.toCol];
                    this.board[move.toRow][move.toCol] = originalPiece;

                    if (isMaximizing) {
                        bestScore = Math.max(bestScore, score);
                        alpha = Math.max(alpha, score);
                    } else {
                        bestScore = Math.min(bestScore, score);
                        beta = Math.min(beta, score);
                    }

                    if (beta <= alpha) break; // Alpha-beta pruning
                }

                return bestScore;
            }

            evaluateBoard() {
                let score = 0;
                const pieceValues = {
                    '‚ôõ': -9, '‚ôú': -5, '‚ôù': -3, '‚ôû': -3, '‚ôü': -1,
                    '‚ôï': 9, '‚ôñ': 5, '‚ôó': 3, '‚ôò': 3, '‚ôô': 1
                };

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            score += pieceValues[piece] || 0;
                            
                            // Position bonuses
                            if (piece === '‚ôü' || piece === '‚ôô') {
                                // Pawn advancement bonus
                                const advancement = piece === '‚ôô' ? (6 - row) : (row - 1);
                                score += (piece === '‚ôô' ? 0.1 : -0.1) * advancement;
                            }
                            
                            // Center control bonus
                            const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);
                            score += (piece === '‚ôô' || piece === '‚ôñ' || piece === '‚ôó' || piece === '‚ôò' || piece === '‚ôï' ? 0.05 : -0.05) * (7 - centerDistance);
                        }
                    }
                }

                return score;
            }

            getAllPossibleMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.board[row][col] && this.isPieceColor(row, col, color)) {
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (this.isValidMove(row, col, toRow, toCol)) {
                                        moves.push({ fromRow: row, fromCol: col, toRow, toCol });
                                    }
                                }
                            }
                        }
                    }
                }
                return moves;
            }

            isPieceColor(row, col, color) {
                const piece = this.board[row][col];
                if (!piece) return false;
                
                const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
                const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
                
                return (color === 'white' && whitePieces.includes(piece)) ||
                       (color === 'black' && blackPieces.includes(piece));
            }

            evaluateMove(move) {
                const piece = this.board[move.fromRow][move.fromCol];
                const target = this.board[move.toRow][move.toCol];
                
                let score = Math.random() * 10;
                
                if (target) {
                    const pieceValues = { 
                        '‚ôõ': 9, '‚ôú': 5, '‚ôù': 3, '‚ôû': 3, '‚ôü': 1,
                        '‚ôï': 9, '‚ôñ': 5, '‚ôó': 3, '‚ôò': 3, '‚ôô': 1 
                    };
                    score += pieceValues[target] || 0;
                }
                
                const centerDistance = Math.abs(3.5 - move.toRow) + Math.abs(3.5 - move.toCol);
                score += (7 - centerDistance) * 0.5;
                
                return score;
            }

            updateUI() {
                document.querySelectorAll('.square').forEach(square => {
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    square.textContent = this.board[row][col] || '';
                });
                
                this.updateGameStatus();
                this.updateMoveHistory();
                this.updateGameControls();
            }

            updateGameStatus() {
                const statusElement = document.getElementById('game-status');
                if (this.gameOver) {
                    statusElement.textContent = `Game k·∫øt th√∫c - ${this.winner} th·∫Øng`;
                } else if (this.gamePaused) {
                    statusElement.textContent = 'Game ƒë√£ t·∫°m d·ª´ng';
                } else {
                    statusElement.textContent = this.currentPlayer === 'white' ? 
                        'L∆∞·ª£t c·ªßa b·∫°n (Tr·∫Øng)' : 'L∆∞·ª£t c·ªßa AI (ƒêen)';
                }
            }

            updateMoveHistory() {
                const historyElement = document.getElementById('move-history');
                if (this.moveHistory.length > 0) {
                    const historyHTML = this.moveHistory.map((move, index) => {
                        const playerColor = move.player === 'white' ? '#4ecdc4' : '#ff6b6b';
                        return `<span style="color: ${playerColor}">${index + 1}. ${move.notation}</span>`;
                    }).join('<br>');
                    historyElement.innerHTML = historyHTML;
                } else {
                    historyElement.innerHTML = 'Game m·ªõi - B·∫°n ƒëi tr∆∞·ªõc!';
                }
                historyElement.scrollTop = historyElement.scrollHeight;
            }

            updateGameControls() {
                const pauseBtn = document.getElementById('pause-game');
                const stopBtn = document.getElementById('stop-game');
                
                if (this.gameOver) {
                    pauseBtn.disabled = true;
                    stopBtn.disabled = true;
                } else {
                    pauseBtn.disabled = false;
                    stopBtn.disabled = false;
                    pauseBtn.textContent = this.gamePaused ? 'Ti·∫øp t·ª•c' : 'T·∫°m d·ª´ng';
                }
            }

            checkGameEnd() {
                const currentMoves = this.getAllPossibleMoves(this.currentPlayer);
                
                if (currentMoves.length === 0) {
                    if (this.isKingInCheck(this.currentPlayer)) {
                        const winner = this.currentPlayer === 'white' ? 'ƒêen' : 'Tr·∫Øng';
                        this.endGame(this.currentPlayer === 'white' ? 'black' : 'white', `Chi·∫øu t∆∞·ªõng - ${winner} th·∫Øng`);
                    } else {
                        this.endGame(null, 'H√≤a - Kh√¥ng th·ªÉ di chuy·ªÉn');
                    }
                } else if (this.moveHistory.length >= 100) {
                    this.endGame(null, 'H√≤a - 50 n∆∞·ªõc kh√¥ng ƒÉn qu√¢n');
                }
            }

            isKingInCheck(color) {
                // Find king position
                let kingRow = -1, kingCol = -1;
                const kingPiece = color === 'white' ? '‚ôî' : '‚ôö';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.board[row][col] === kingPiece) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                    if (kingRow !== -1) break;
                }

                if (kingRow === -1) return false;

                // Check if any opponent piece can attack the king
                const opponentColor = color === 'white' ? 'black' : 'white';
                const opponentMoves = this.getAllPossibleMoves(opponentColor);
                
                return opponentMoves.some(move => move.toRow === kingRow && move.toCol === kingCol);
            }

            pauseGame() {
                this.gamePaused = !this.gamePaused;
                this.updateGameStatus();
                this.updateGameControls();
                
                if (this.gamePaused) {
                    showNotification('Game ƒë√£ t·∫°m d·ª´ng', 'warning');
                } else {
                    showNotification('Game ti·∫øp t·ª•c', 'success');
                }
            }

            stopGame() {
                if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën d·ª´ng tr·∫≠n ƒë·∫•u? (K·∫øt qu·∫£ s·∫Ω ƒë∆∞·ª£c ghi nh·∫≠n)')) {
                    this.endGame(null, 'Ng∆∞·ªùi ch∆°i d·ª´ng tr·∫≠n ƒë·∫•u');
                }
            }

            endGame(winner, reason) {
                this.gameOver = true;
                this.winner = winner;
                this.gameEndReason = reason;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }

                this.updateUI();
                setTimeout(() => this.showGameOverModal(), 500);
            }

            showGameOverModal() {
                const modal = document.getElementById('game-over-modal');
                const title = document.getElementById('game-result-title');
                const winnerText = document.getElementById('winner-text');
                const reasonText = document.getElementById('win-reason');

                if (this.winner === null) {
                    title.textContent = 'ü§ù Tr·∫≠n ƒë·∫•u h√≤a!';
                    winnerText.textContent = 'K·∫øt qu·∫£: H√≤a';
                } else if (this.winner === 'white') {
                    title.textContent = 'üéâ B·∫°n th·∫Øng!';
                    winnerText.textContent = 'Ng∆∞·ªùi chi·∫øn th·∫Øng: B·∫°n (Tr·∫Øng)';
                } else {
                    title.textContent = 'ü§ñ AI th·∫Øng!';
                    winnerText.textContent = 'Ng∆∞·ªùi chi·∫øn th·∫Øng: AI (ƒêen)';
                }

                reasonText.textContent = this.gameEndReason;

                // Update game stats
                const gameDuration = this.gameStartTime ? 
                    Math.floor((Date.now() - this.gameStartTime) / 1000) : 0;
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                };

                document.getElementById('total-moves').textContent = this.moveHistory.length;
                document.getElementById('game-duration').textContent = formatTime(gameDuration);
                
                const difficultyNames = ['', 'D·ªÖ', 'Trung b√¨nh', 'Kh√≥', 'Chuy√™n gia'];
                document.getElementById('ai-difficulty-used').textContent = difficultyNames[this.aiDifficulty];
                
                document.getElementById('fhe-usage').textContent = 
                    (window.fheManager && window.fheManager.isInitialized) ? 'C√≥' : 'Kh√¥ng';

                modal.style.display = 'flex';

                // Record game result on blockchain if connected
                if (window.web3Manager && window.web3Manager.isConnected) {
                    console.log('Recording game result on blockchain...');
                }
            }

            newGame() {
                if (this.timerInterval) clearInterval(this.timerInterval);
                
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveHistory = [];
                this.gameOver = false;
                this.gamePaused = false;
                this.gameStartTime = null;
                this.whiteTime = 600;